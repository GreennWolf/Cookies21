/**
 * Utilidades de validaci√≥n para anidamiento de contenedores - FASE 4
 * Sistema robusto para prevenir loops circulares y controlar profundidad
 */

/**
 * Profundidad m√°xima permitida para anidamiento de contenedores
 */
export const MAX_NESTING_DEPTH = 5;


/**
 * Calcula la profundidad de anidamiento actual de un componente
 * @param {Object} component - El componente a analizar
 * @param {Array} allComponents - Todos los componentes del banner
 * @param {number} currentDepth - Profundidad actual (para recursi√≥n)
 * @returns {number} La profundidad de anidamiento
 */
export function calculateNestingDepth(component, allComponents = [], currentDepth = 0) {
  // Si no tiene padre, est√° en el nivel ra√≠z
  if (!component.parentId) {
    return currentDepth;
  }
  
  // Buscar el componente padre
  const parent = findComponentById(component.parentId, allComponents);
  if (!parent) {
    // Padre no encontrado, asumir nivel ra√≠z
    return currentDepth;
  }
  
  // Recursi√≥n: calcular profundidad del padre + 1
  return calculateNestingDepth(parent, allComponents, currentDepth + 1);
}

/**
 * Busca un componente por ID en la estructura anidada
 * @param {string} componentId - ID del componente a buscar
 * @param {Array} components - Array de componentes donde buscar
 * @returns {Object|null} El componente encontrado o null
 */
export function findComponentById(componentId, components) {
  if (!Array.isArray(components)) return null;
  
  for (const comp of components) {
    // Verificar si es el componente buscado
    if (comp.id === componentId) {
      return comp;
    }
    
    // Buscar en los hijos recursivamente
    if (comp.children && Array.isArray(comp.children)) {
      const found = findComponentById(componentId, comp.children);
      if (found) return found;
    }
  }
  
  return null;
}

/**
 * Obtiene la cadena de ancestros de un componente
 * @param {Object} component - El componente
 * @param {Array} allComponents - Todos los componentes del banner
 * @returns {Array} Array de IDs de ancestros (desde el m√°s cercano al m√°s lejano)
 */
export function getAncestorChain(component, allComponents = []) {
  const ancestors = [];
  let current = component;
  
  while (current && current.parentId) {
    const parent = findComponentById(current.parentId, allComponents);
    if (!parent) break;
    
    ancestors.push(parent.id);
    current = parent;
  }
  
  return ancestors;
}

/**
 * Verifica si un componente es ancestro de otro
 * @param {string} potentialAncestorId - ID del posible ancestro
 * @param {Object} component - El componente descendiente
 * @param {Array} allComponents - Todos los componentes del banner
 * @returns {boolean} true si es ancestro
 */
export function isAncestor(potentialAncestorId, component, allComponents = []) {
  const ancestorChain = getAncestorChain(component, allComponents);
  return ancestorChain.includes(potentialAncestorId);
}

/**
 * Verifica si un componente es descendiente de otro
 * @param {string} potentialDescendantId - ID del posible descendiente
 * @param {Object} component - El componente ancestro
 * @returns {boolean} true si es descendiente
 */
export function isDescendant(potentialDescendantId, component) {
  if (!component.children || !Array.isArray(component.children)) {
    return false;
  }
  
  // Buscar en hijos directos
  for (const child of component.children) {
    if (child.id === potentialDescendantId) {
      return true;
    }
    
    // Buscar recursivamente en nietos
    if (isDescendant(potentialDescendantId, child)) {
      return true;
    }
  }
  
  return false;
}

/**
 * Detecta si agregar un componente como hijo crear√≠a un loop circular
 * @param {Object} parentContainer - El contenedor padre
 * @param {Object} childComponent - El componente a agregar como hijo
 * @param {Array} allComponents - Todos los componentes del banner
 * @returns {Object} { hasLoop: boolean, reason?: string, loopPath?: Array }
 */
export function detectCircularReference(parentContainer, childComponent, allComponents = []) {
  // Caso 1: El componente no puede ser padre de s√≠ mismo
  if (parentContainer.id === childComponent.id) {
    return {
      hasLoop: true,
      reason: 'Un contenedor no puede contenerse a s√≠ mismo',
      loopPath: [parentContainer.id]
    };
  }
  
  // Caso 2: El componente hijo no puede ser un ancestro del padre
  // (esto crear√≠a un loop: A ‚Üí B ‚Üí A)
  if (isAncestor(childComponent.id, parentContainer, allComponents)) {
    const ancestorChain = getAncestorChain(parentContainer, allComponents);
    const loopStart = ancestorChain.indexOf(childComponent.id);
    const loopPath = [parentContainer.id, ...ancestorChain.slice(0, loopStart + 1)];
    
    return {
      hasLoop: true,
      reason: `Crear este anidamiento formar√≠a un loop circular: ${loopPath.join(' ‚Üí ')}`,
      loopPath
    };
  }
  
  // Caso 3: El contenedor padre no puede ser descendiente del hijo
  // (variaci√≥n del caso anterior)
  if (childComponent.type === 'container' && isDescendant(parentContainer.id, childComponent)) {
    return {
      hasLoop: true,
      reason: 'El contenedor padre no puede ser descendiente del componente hijo',
      loopPath: [childComponent.id, parentContainer.id]
    };
  }
  
  return { hasLoop: false };
}

/**
 * Validaci√≥n completa para anidamiento de contenedores
 * @param {Object} parentContainer - El contenedor padre
 * @param {Object} childComponent - El componente a anidar
 * @param {Array} allComponents - Todos los componentes del banner
 * @returns {Object} { isValid: boolean, reason?: string, details?: Object }
 */
export function validateContainerNesting(parentContainer, childComponent, allComponents = []) {
  // 1. Verificar que el padre es realmente un contenedor
  if (parentContainer.type !== 'container') {
    return {
      isValid: false,
      reason: 'El componente de destino no es un contenedor',
      details: { code: 'NOT_CONTAINER' }
    };
  }
  
  // 2. Verificar profundidad m√°xima
  const currentDepth = calculateNestingDepth(parentContainer, allComponents);
  if (currentDepth >= MAX_NESTING_DEPTH) {
    return {
      isValid: false,
      reason: `Se ha alcanzado la profundidad m√°xima de anidamiento (${MAX_NESTING_DEPTH} niveles)`,
      details: { 
        code: 'MAX_DEPTH_EXCEEDED',
        currentDepth,
        maxDepth: MAX_NESTING_DEPTH
      }
    };
  }
  
  // 3. Si el hijo es un contenedor, verificar loops circulares
  if (childComponent.type === 'container') {
    const circularCheck = detectCircularReference(parentContainer, childComponent, allComponents);
    if (circularCheck.hasLoop) {
      return {
        isValid: false,
        reason: circularCheck.reason,
        details: {
          code: 'CIRCULAR_REFERENCE',
          loopPath: circularCheck.loopPath
        }
      };
    }
    
    // 4. Verificar que el anidamiento resultante no exceder√≠a la profundidad m√°xima
    const childDepth = calculateNestingDepth(childComponent, allComponents);
    const resultingDepth = currentDepth + 1 + childDepth;
    
    if (resultingDepth > MAX_NESTING_DEPTH) {
      return {
        isValid: false,
        reason: `El anidamiento resultar√≠a en una profundidad de ${resultingDepth}, excediendo el m√°ximo de ${MAX_NESTING_DEPTH}`,
        details: {
          code: 'RESULTING_DEPTH_EXCEEDED',
          currentDepth,
          childDepth,
          resultingDepth,
          maxDepth: MAX_NESTING_DEPTH
        }
      };
    }
  }
  
  // 5. Verificaciones adicionales de compatibilidad
  const maxChildren = getMaxChildrenForContainer(parentContainer);
  const currentChildrenCount = parentContainer.children?.length || 0;
  
  if (currentChildrenCount >= maxChildren) {
    return {
      isValid: false,
      reason: `El contenedor ha alcanzado el l√≠mite m√°ximo de ${maxChildren} componentes`,
      details: {
        code: 'MAX_CHILDREN_EXCEEDED',
        currentCount: currentChildrenCount,
        maxChildren
      }
    };
  }
  
  return {
    isValid: true,
    details: {
      currentDepth,
      resultingDepth: currentDepth + 1,
      maxDepth: MAX_NESTING_DEPTH
    }
  };
}

/**
 * Obtiene el n√∫mero m√°ximo de hijos para un contenedor basado en su configuraci√≥n
 * @param {Object} containerComponent - El componente contenedor
 * @param {string} deviceView - Vista del dispositivo (opcional)
 * @returns {number} N√∫mero m√°ximo de hijos
 */
function getMaxChildrenForContainer(containerComponent, deviceView = 'desktop') {
  const containerConfig = containerComponent.containerConfig?.[deviceView] || {};
  const displayMode = containerConfig.displayMode || 'libre';
  
  switch (displayMode) {
    case 'libre':
      return 10; // M√°ximo 10 componentes en modo libre
    case 'flex':
      return 8; // M√°ximo 8 componentes en flexbox
    case 'grid':
      // Calcular basado en la configuraci√≥n del grid
      const columns = containerConfig.gridTemplateColumns || 'repeat(2, 1fr)';
      if (columns.includes('repeat(')) {
        const match = columns.match(/repeat\((\d+),/);
        if (match) {
          const cols = parseInt(match[1]);
          return cols * 3; // M√°ximo 3 filas por defecto
        }
      }
      return 6; // Fallback para grid
    default:
      return 5;
  }
}

/**
 * Obtiene indicadores visuales para mostrar el nivel de anidamiento
 * @param {number} depth - Profundidad actual
 * @returns {Object} Informaci√≥n de visualizaci√≥n del nivel
 */
export function getNestingLevelIndicator(depth) {
  const levels = [
    { color: '#3b82f6', name: 'Nivel 1', icon: '‚ñ´Ô∏è' },
    { color: '#10b981', name: 'Nivel 2', icon: '‚ñ™Ô∏è' },
    { color: '#f59e0b', name: 'Nivel 3', icon: 'üî∏' },
    { color: '#ef4444', name: 'Nivel 4', icon: 'üî∫' },
    { color: '#8b5cf6', name: 'Nivel 5', icon: '‚¨®' }
  ];
  
  if (depth >= levels.length) {
    return {
      color: '#dc2626',
      name: `Nivel ${depth + 1} (M√°ximo excedido)`,
      icon: '‚ö†Ô∏è',
      isExceeded: true
    };
  }
  
  return {
    ...levels[depth],
    isExceeded: false
  };
}

/**
 * Genera mensajes de error amigables para el usuario
 * @param {Object} validationResult - Resultado de la validaci√≥n
 * @returns {Object} Mensaje formateado para mostrar al usuario
 */
export function formatNestingErrorMessage(validationResult) {
  if (validationResult.isValid) {
    return null;
  }
  
  const { reason, details } = validationResult;
  
  const baseMessage = {
    title: '‚ùå No se puede realizar esta acci√≥n',
    description: reason,
    type: 'error'
  };
  
  // Personalizar mensaje seg√∫n el tipo de error
  switch (details?.code) {
    case 'NOT_CONTAINER':
      return {
        ...baseMessage,
        title: '‚ùå Destino inv√°lido',
        suggestion: 'Solo puedes agregar componentes dentro de contenedores.'
      };
      
    case 'MAX_DEPTH_EXCEEDED':
      return {
        ...baseMessage,
        title: 'üìä Profundidad m√°xima alcanzada',
        suggestion: `Intenta crear un nuevo contenedor en un nivel superior. M√°ximo permitido: ${details.maxDepth} niveles.`
      };
      
    case 'CIRCULAR_REFERENCE':
      return {
        ...baseMessage,
        title: 'üîÑ Referencia circular detectada',
        suggestion: 'Este anidamiento crear√≠a un loop infinito. Reorganiza la estructura de contenedores.',
        technicalDetails: `Ruta del loop: ${details.loopPath?.join(' ‚Üí ')}`
      };
      
    case 'RESULTING_DEPTH_EXCEEDED':
      return {
        ...baseMessage,
        title: 'üìà Anidamiento muy profundo',
        suggestion: `El anidamiento resultante (${details.resultingDepth} niveles) excede el m√°ximo permitido (${details.maxDepth}).`
      };
      
    case 'MAX_CHILDREN_EXCEEDED':
      return {
        ...baseMessage,
        title: 'üë• Contenedor lleno',
        suggestion: `Este contenedor ya tiene ${details.currentCount} componentes (m√°ximo: ${details.maxChildren}). Considera usar otro contenedor.`
      };
      
    default:
      return baseMessage;
  }
}

/**
 * Valida una operaci√≥n de drag & drop en tiempo real
 * @param {Object} draggedComponent - Componente siendo arrastrado
 * @param {Object} targetContainer - Contenedor objetivo
 * @param {Array} allComponents - Todos los componentes
 * @param {Object} dragPosition - Posici√≥n del cursor durante el drag
 * @returns {Object} Estado de validaci√≥n para mostrar indicadores visuales
 */
export function validateDragOperation(draggedComponent, targetContainer, allComponents = [], dragPosition = null) {
  // Validaci√≥n b√°sica de anidamiento
  const nestingValidation = validateContainerNesting(targetContainer, draggedComponent, allComponents);
  
  if (!nestingValidation.isValid) {
    return {
      isValid: false,
      showError: true,
      errorMessage: formatNestingErrorMessage(nestingValidation),
      canDrop: false
    };
  }
  
  // Si la validaci√≥n es exitosa, permitir el drop
  return {
    isValid: true,
    showError: false,
    canDrop: true,
    nestingInfo: {
      currentDepth: nestingValidation.details.currentDepth,
      resultingDepth: nestingValidation.details.resultingDepth,
      levelIndicator: getNestingLevelIndicator(nestingValidation.details.resultingDepth)
    }
  };
}


/**
 * Utilidad para debug: muestra la estructura completa de anidamiento
 * @param {Array} components - Componentes del banner
 * @param {number} indent - Nivel de indentaci√≥n (para recursi√≥n)
 */
export function debugNestingStructure(components, indent = 0) {
  if (!Array.isArray(components)) return;
  
  const indentStr = '  '.repeat(indent);
  
  components.forEach(comp => {
    const depthInfo = calculateNestingDepth(comp, components);
    console.log(`${indentStr}${comp.type}[${comp.id}] - Depth: ${depthInfo}`);
    
    if (comp.children && comp.children.length > 0) {
      debugNestingStructure(comp.children, indent + 1);
    }
  });
}