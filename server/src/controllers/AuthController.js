// controllers/AuthController.js
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const Client = require('../models/Client');
const UserAccount = require('../models/UserAccount');
const AppError = require('../utils/appError');
const { catchAsync } = require('../utils/catchAsync');

class AuthController {
  // Registro de cliente
  register = catchAsync(async (req, res, next) => {
    const { name, email, password, company, subscription = 'basic' } = req.body;
    console.log(`üìù Intento de registro para: ${email}`);

    // Validar que se hayan enviado los campos requeridos
    if (!name || !email || !password || !company) {
      console.log('‚ùå Faltan campos requeridos en el registro');
      return next(
        new AppError('Missing required fields: name, email, password and company are required', 400)
      );
    }

    // Validar el formato de email (expresi√≥n regular sencilla)
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      console.log('‚ùå Formato de email inv√°lido');
      return next(new AppError('Invalid email format', 400));
    }

    // Verificar si el email ya existe
    const existingClient = await Client.findOne({ email });
    if (existingClient) {
      console.log('‚ùå Email ya en uso');
      return next(new AppError('Email already in use', 409));
    }

    // Crear cliente
    console.log('üìù Creando cliente...');
    const client = await Client.create({
      name,
      email,
      password,
      company,
      subscription: {
        plan: subscription,
        startDate: new Date()
      }
    });
    console.log(`‚úÖ Cliente creado con ID: ${client._id}`);

    // Generar API Key inicial
    console.log('üìù Generando API Key inicial...');
    const apiKey = await client.generateApiKey({
      name: 'Default Key',
      permissions: ['read', 'write']
    });
    console.log(`‚úÖ API Key generada: ${apiKey.key.substring(0, 10)}...`);

    // Crear usuario administrador
    console.log('üìù Creando usuario admin...');
    const adminUser = await UserAccount.create({
      clientId: client._id,
      email,
      password,
      name,
      role: 'admin',
      status: 'active'
    });
    console.log(`‚úÖ Usuario admin creado con ID: ${adminUser._id}`);

    // Generar tokens
    const tokens = this._createTokens(client._id);

    return res.status(201).json({
      status: 'success',
      data: {
        client: {
          id: client._id,
          name: client.name,
          email: client.email,
          apiKey: apiKey.key
        },
        tokens
      }
    });
  });

  // Login
  login = catchAsync(async (req, res, next) => {
    const { email, password } = req.body;
    console.log(`\n\nüîê ======== NUEVO INTENTO DE LOGIN ======== üîê`);
    console.log(`üîç Intento de login para: ${email}`);
    console.log(`üîç Contrase√±a proporcionada (longitud): ${password ? password.length : 0} caracteres`);

    // Verificar si se proporcion√≥ email y password
    if (!email || !password) {
      console.log('‚ùå Email o password no proporcionados');
      return next(new AppError('Please provide email and password', 400));
    }

    // Buscar cliente o usuario con el campo password incluido
    console.log(`üîç Buscando cliente con email: ${email}`);
    const client = await Client.findOne({ email }).select('+password');
    
    console.log(`üîç Buscando usuario con email: ${email}`);
    const userAccount = await UserAccount.findOne({ email }).select('+password');
    
    console.log(`üîç Cliente encontrado: ${client ? 'S√ç' : 'NO'}`);
    console.log(`üîç Usuario encontrado: ${userAccount ? 'S√ç' : 'NO'}`);
    
    if (userAccount) {
      // Muestra informaci√≥n del usuario pero oculta la contrase√±a completa
      const userInfo = { ...userAccount.toObject() };
      if (userInfo.password) {
        userInfo.password = `${userInfo.password.substring(0, 10)}... (${userInfo.password.length} caracteres)`;
      }
      console.log(`üîç Informaci√≥n del usuario:`, JSON.stringify(userInfo, null, 2));
      
      console.log(`üîç Rol del usuario: ${userAccount.role}`);
      console.log(`üîç Estado del usuario: ${userAccount.status}`);
      console.log(`üîç Tiene clientId: ${userAccount.clientId ? 'S√ç' : 'NO'}`);
      
      // Verificar m√©todos disponibles en el modelo UserAccount
      console.log(`üîç M√©todo verifyPassword disponible: ${typeof userAccount.verifyPassword === 'function' ? 'S√ç' : 'NO'}`);
      
      // Inspeccionar el hash de la contrase√±a almacenada
      if (userAccount.password) {
        console.log(`üîç Contrase√±a almacenada (hash): ${userAccount.password.substring(0, 10)}...`);
        console.log(`üîç Longitud del hash: ${userAccount.password.length} caracteres`);
        console.log(`üîç ¬øParece un hash bcrypt? ${userAccount.password.startsWith('$2') ? 'S√ç' : 'NO'}`);
      } else {
        console.log(`‚ùå No hay contrase√±a almacenada para este usuario`);
      }
    }

    const user = userAccount;
    if (!user) {
      console.log('‚ùå No se encontr√≥ ning√∫n usuario con este email');
      return next(new AppError('Invalid credentials', 401));
    }

    // Verificar password
    try {
      console.log('üîç Verificando contrase√±a...');
      console.log(`üîç Contrase√±a proporcionada: ${password}`);
      console.log(`üîç Contrase√±a almacenada (parcial): ${user.password.substring(0, 10)}...`);
      
      // Hacemos una verificaci√≥n manual con bcrypt para diagnosticar
      console.log('üîç Intentando verificaci√≥n manual con bcrypt...');
      try {
        const manualCompare = await bcrypt.compare(password, user.password);
        console.log(`üîç Resultado de comparaci√≥n manual: ${manualCompare ? '√âXITO' : 'FALLO'}`);
      } catch (bcryptError) {
        console.log(`‚ùå Error en comparaci√≥n manual de bcrypt: ${bcryptError.message}`);
      }
      
      // Ahora hacemos la verificaci√≥n con el m√©todo del modelo
      console.log('üîç Intentando verificaci√≥n a trav√©s del m√©todo del modelo...');
      const isPasswordValid = await user.verifyPassword(password);
      console.log(`üîç Contrase√±a v√°lida (m√©todo del modelo): ${isPasswordValid ? 'S√ç' : 'NO'}`);
      
      if (!isPasswordValid) {
        console.log('‚ùå Contrase√±a incorrecta');
        return next(new AppError('Invalid credentials', 401));
      }
    } catch (error) {
      console.log(`‚ùå Error al verificar contrase√±a: ${error.message}`);
      console.log(error.stack);
      return next(new AppError('Error verifying credentials', 500));
    }

    // Verificar estado de la cuenta
    if (user.status !== 'active') {
      console.log(`‚ùå Cuenta no activa: ${user.status}`);
      return next(new AppError('Account is not active', 401));
    }

    // MANEJO ESPECIAL PARA ROLE OWNER
    let clientId = null;
    console.log(`üîç Verificando rol para clientId: ${userAccount.role}`);
    
    // Si NO es owner, obtener el clientId
    if (userAccount && userAccount.role !== 'owner') {
      clientId = client ? client._id : userAccount.clientId;
      console.log(`üîç ClientId asignado: ${clientId}`);
      
      // Verificar que el cliente exista y est√© activo
      if (clientId) {
        const associatedClient = await Client.findById(clientId);
        if (!associatedClient || associatedClient.status !== 'active') {
          console.log('‚ùå Cliente inactivo o no existente');
          return next(new AppError('Client account is not active', 403));
        }
      }
    } else {
      console.log('‚úÖ Usuario owner detectado, no se requiere clientId');
    }

    console.log(`üîç Generando tokens para userId=${user._id}, clientId=${clientId}`);
    
    // Generar tokens
    const tokens = this._createTokens(clientId, user._id);

    // Actualizar √∫ltimo login para UserAccount
    try {
      if (!userAccount.accessControl) {
        console.log('‚ö†Ô∏è accessControl no exist√≠a, inicializando...');
        userAccount.accessControl = {};
      }
      
      userAccount.accessControl.lastLogin = new Date();
      // Tambi√©n reseteamos intentos fallidos
      userAccount.accessControl.failedAttempts = 0;
      userAccount.accessControl.lockUntil = undefined;
      
      await userAccount.save();
      console.log('‚úÖ √öltimo login actualizado correctamente');
    } catch (error) {
      console.log(`‚ö†Ô∏è Error al actualizar √∫ltimo login: ${error.message}`);
      console.log(error.stack);
      // No bloqueamos el login si esto falla
    }

    console.log('‚úÖ Login exitoso');
    return res.status(200).json({
      status: 'success',
      data: {
        user: {
          id: user._id,
          name: user.name,
          email: user.email,
          clientId: user.clientId,
          role: userAccount ? userAccount.role : 'client'
        },
        tokens
      }
    });
  });

  // Refresh Token
  refreshToken = catchAsync(async (req, res, next) => {
    const { refreshToken } = req.body;
    console.log(`üîÑ Solicitud de refresh token recibida`);

    if (!refreshToken) {
      console.log('‚ùå No se proporcion√≥ refresh token');
      return next(new AppError('No refresh token provided', 400));
    }

    let decoded;
    try {
      decoded = jwt.verify(refreshToken, process.env.JWT_SECRET);
      console.log(`üîç Token decodificado:`, decoded);
    } catch (error) {
      console.log(`‚ùå Error al verificar refresh token: ${error.message}`);
      return next(new AppError('Invalid or expired refresh token', 401));
    }

    const { clientId, userId } = decoded;
    console.log(`üîç Refresh token: clientId=${clientId}, userId=${userId}`);

    // Si hay userId, verificamos primero el usuario
    if (userId) {
      const userAccount = await UserAccount.findById(userId);
      
      if (!userAccount) {
        console.log('‚ùå Usuario no encontrado');
        return next(new AppError('User no longer exists', 401));
      }
      
      if (userAccount.status !== 'active') {
        console.log(`‚ùå Usuario no activo: ${userAccount.status}`);
        return next(new AppError('User account is no longer active', 401));
      }
      
      console.log(`üîç Rol del usuario: ${userAccount.role}`);
      
      // Si es owner, no necesitamos verificar el cliente
      if (userAccount.role === 'owner') {
        console.log('‚úÖ Usuario owner detectado en refresh token');
        // Generar nuevos tokens sin clientId para owners
        const tokens = this._createTokens(null, userId);
        return res.status(200).json({
          status: 'success',
          data: { tokens }
        });
      }
    }

    // Verificar si el cliente a√∫n existe y est√° activo (para no-owners)
    if (clientId) {
      const client = await Client.findById(clientId);
      if (!client || client.status !== 'active') {
        console.log('‚ùå Cliente no activo o no existente');
        return next(new AppError('Client no longer active', 401));
      }
    }

    // Generar nuevos tokens
    console.log('‚úÖ Generando nuevos tokens');
    const tokens = this._createTokens(clientId, userId);

    return res.status(200).json({
      status: 'success',
      data: { tokens }
    });
  });

  // Logout
  logout = catchAsync(async (req, res) => {
    console.log(`üö™ Logout de usuario: ${req.userId}`);
    
    // Aqu√≠ puedes implementar l√≥gica adicional como:
    // - Agregar el token a una lista negra
    // - Limpiar sesiones del usuario
    // - Actualizar √∫ltimo logout

    return res.status(200).json({
      status: 'success',
      message: 'Logged out successfully'
    });
  });

  // Cambiar contrase√±a
  changePassword = catchAsync(async (req, res, next) => {
    const { currentPassword, newPassword } = req.body;
    const { userId, userType } = req;
    
    console.log(`üîë Solicitud de cambio de contrase√±a para userId=${userId}, userType=${userType}`);

    const UserModel = userType === 'client' ? Client : UserAccount;
    const user = await UserModel.findById(userId).select('+password');

    if (!user) {
      console.log('‚ùå Usuario no encontrado');
      return next(new AppError('User not found', 404));
    }

    // Verificar password actual
    console.log('üîç Verificando contrase√±a actual...');
    const isPasswordValid = await user.verifyPassword(currentPassword);
    console.log(`üîç Contrase√±a actual v√°lida: ${isPasswordValid ? 'S√ç' : 'NO'}`);
    
    if (!isPasswordValid) {
      console.log('‚ùå Contrase√±a actual incorrecta');
      return next(new AppError('Current password is incorrect', 401));
    }

    // Actualizar password
    console.log('üîç Actualizando contrase√±a...');
    user.password = newPassword;
    await user.save();
    console.log('‚úÖ Contrase√±a actualizada correctamente');

    return res.status(200).json({
      status: 'success',
      message: 'Password changed successfully'
    });
  });

  // Solicitud de reset de contrase√±a
  forgotPassword = catchAsync(async (req, res, next) => {
    const { email } = req.body;
    console.log(`üîë Solicitud de recuperaci√≥n de contrase√±a para: ${email}`);

    // Buscar usuario
    const client = await Client.findOne({ email });
    const userAccount = await UserAccount.findOne({ email });
    
    const user = client || userAccount;
    if (!user) {
      console.log('‚ùå No se encontr√≥ ning√∫n usuario con este email');
      return next(new AppError('No user found with that email', 404));
    }

    console.log(`‚úÖ Usuario encontrado: ${user._id}`);

    // Asegurarnos de que el campo security exista
    if (!user.security) {
      console.log('‚ö†Ô∏è Campo security no exist√≠a, inicializando...');
      user.security = {};
    }

    // Generar token de reset
    const resetToken = user.createPasswordResetToken();
    await user.save({ validateBeforeSave: false });
    console.log(`‚úÖ Token de reset generado: ${resetToken.substring(0, 10)}...`);

    try {
      // Aqu√≠ implementar√≠as el env√≠o del email, por ejemplo:
      // await sendPasswordResetEmail(email, resetToken);
      console.log('‚úÖ Token de reset listo para enviar por email');

      return res.status(200).json({
        status: 'success',
        message: 'Reset token sent to email'
      });
    } catch (error) {
      // Si hay error, limpiar el token y expiraci√≥n
      console.log(`‚ùå Error al enviar email: ${error.message}`);
      user.security.passwordResetToken = undefined;
      user.security.passwordResetExpires = undefined;
      await user.save({ validateBeforeSave: false });

      return next(new AppError('Error sending email. Please try again later.', 500));
    }
  });

  // Reset de contrase√±a
  resetPassword = catchAsync(async (req, res, next) => {
    const { token, newPassword } = req.body;
    console.log(`üîë Solicitud de reset de contrase√±a con token: ${token ? token.substring(0, 10) : 'no token'}...`);

    // Buscar usuario con token v√°lido
    const client = await Client.findOne({
      'security.passwordResetToken': token,
      'security.passwordResetExpires': { $gt: Date.now() }
    });

    const userAccount = await UserAccount.findOne({
      'security.passwordResetToken': token,
      'security.passwordResetExpires': { $gt: Date.now() }
    });

    console.log(`üîç Cliente encontrado con token: ${client ? 'S√ç' : 'NO'}`);
    console.log(`üîç Usuario encontrado con token: ${userAccount ? 'S√ç' : 'NO'}`);

    const user = client || userAccount;
    if (!user) {
      console.log('‚ùå Token inv√°lido o expirado');
      return next(new AppError('Token is invalid or has expired', 400));
    }

    // Asegurarnos de que el campo security exista
    if (!user.security) {
      console.log('‚ö†Ô∏è Campo security no exist√≠a, inicializando...');
      user.security = {};
    }

    // Actualizar password y limpiar tokens
    console.log('üîç Actualizando contrase√±a...');
    user.password = newPassword;
    user.security.passwordResetToken = undefined;
    user.security.passwordResetExpires = undefined;
    await user.save();
    console.log('‚úÖ Contrase√±a reseteada correctamente');

    return res.status(200).json({
      status: 'success',
      message: 'Password reset successfully'
    });
  });

  // Verificar estado de sesi√≥n
  checkSession = catchAsync(async (req, res, next) => {
    // Esta funci√≥n asume que el middleware 'protect' ya verific√≥ el token
    const { clientId, userId, userType } = req;
    console.log(`üîç Verificando sesi√≥n: userId=${userId}, clientId=${clientId}, userType=${userType}`);

    // Si no hay userId, significa que el usuario est√° autenticado como cliente
    if (!userId) {
      console.log('üîç Sesi√≥n de cliente, buscando informaci√≥n...');
      const client = await Client.findById(clientId);
      
      if (!client) {
        console.log('‚ùå Cliente no encontrado');
        return next(new AppError('Client not found', 404));
      }
      
      console.log('‚úÖ Informaci√≥n de cliente obtenida');
      return res.status(200).json({
        status: 'success',
        data: {
          user: {
            id: client._id,
            name: client.name,
            email: client.email,
            role: 'client'
          }
        }
      });
    }

    // Si hay userId, es un UserAccount
    console.log('üîç Sesi√≥n de usuario, buscando informaci√≥n...');
    const user = await UserAccount.findById(userId);
    
    if (!user) {
      console.log('‚ùå Usuario no encontrado');
      return next(new AppError('User not found', 404));
    }

    console.log('‚úÖ Informaci√≥n de usuario obtenida');
    return res.status(200).json({
      status: 'success',
      data: {
        user: {
          id: user._id,
          name: user.name,
          email: user.email,
          role: user.role,
          clientId: user.role !== 'owner' ? user.clientId : null
        }
      }
    });
  });

  // M√©todo para crear hash bcrypt manualmente (para depuraci√≥n)
  async _createPasswordHash(password) {
    try {
      console.log(`üîç Generando hash para contrase√±a: ${password}`);
      const salt = await bcrypt.genSalt(12);
      console.log(`üîç Salt generado: ${salt}`);
      const hash = await bcrypt.hash(password, salt);
      console.log(`üîç Hash generado: ${hash}`);
      return hash;
    } catch (error) {
      console.log(`‚ùå Error al generar hash: ${error.message}`);
      throw error;
    }
  }

  // M√©todo para comparar contrase√±as manualmente (para depuraci√≥n)
  async _comparePasswords(plainPassword, hashedPassword) {
    try {
      console.log(`üîç Comparando contrase√±as manualmente`);
      console.log(`üîç Contrase√±a plana: ${plainPassword}`);
      console.log(`üîç Contrase√±a hasheada: ${hashedPassword.substring(0, 10)}...`);
      const result = await bcrypt.compare(plainPassword, hashedPassword);
      console.log(`üîç Resultado de comparaci√≥n: ${result ? '√âXITO' : 'FALLO'}`);
      return result;
    } catch (error) {
      console.log(`‚ùå Error al comparar contrase√±as: ${error.message}`);
      throw error;
    }
  }

  // M√©todo privado para crear tokens
  _createTokens(clientId, userId = null) {
    // Preparar payload
    const payload = { userId };
    
    // Solo incluir clientId si existe (para no-owners)
    if (clientId) {
      payload.clientId = clientId;
    }
    
    console.log(`üîç Creando tokens con payload:`, payload);

    // Access Token
    const accessToken = jwt.sign(
      payload,
      process.env.JWT_SECRET,
      { expiresIn: process.env.JWT_EXPIRES_IN || '15m' }
    );

    // Refresh Token
    const refreshToken = jwt.sign(
      payload,
      process.env.JWT_SECRET,
      { expiresIn: process.env.JWT_REFRESH_EXPIRES_IN || '7d' }
    );

    return { accessToken, refreshToken };
  }
}

// M√©todo para hashear una contrase√±a directamente (para uso en scripts)
AuthController.hashPassword = async (password) => {
  console.log(`üí° Generando hash para contrase√±a: ${password}`);
  try {
    const salt = await bcrypt.genSalt(12);
    const hash = await bcrypt.hash(password, salt);
    console.log(`üí° Hash generado: ${hash}`);
    return hash;
  } catch (error) {
    console.log(`‚ùå Error al generar hash: ${error.message}`);
    throw error;
  }
};

module.exports = new AuthController();